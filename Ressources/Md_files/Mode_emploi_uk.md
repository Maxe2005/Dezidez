# Як користуватися:

- Функції, які можна використовувати: sin(), cos(), tan(), sqrt(), exp(), log(), abs(), sinc(), ціле(),
- Для від'ємних значень завжди використовуйте дужки, наприклад: sin(-2) => sin((-2)) або -4 => (-4)
- Для піднесення до степеня використовуйте '**', наприклад: x у степені y => x**y
- Для десяткових чисел використовуйте '.' замість ','
- всі великі літери вважаються малими

## 1. Початок:

Початковий екран полегшує доступ до функцій, таких як посібник користувача, подяки або запуск режиму відображення з 3D-версією в розробці.

## 2. Повернення:

Щоб повернутися до попередніх меню без перезапуску програми, натисніть на іконку дому або використовуйте клавішу "Backspace" або "Повернутися".

## 3. Верхня панель:

Дозволяє відображати та змінювати до 20 виразів з інтерактивними функціями.

   - Зміна кольору: Виберіть новий колір в реальному часі через іконку колеса.

   - Приховати функцію: Приховуйте або відображайте функцію за потребою в реальному часі.

   - Видалити функцію: Натисніть на іконку сміттєвого бака, щоб видалити вираз.

   - Змінити межі: Налаштуйте межі виразу через текстове вікно для більшої гнучкості.

## 4. Відображення функцій:

Оцінка функцій динамічно оновлює їх графічне представлення.

   - Масштабування: Використовуйте колесо миші для налаштування відображення графіка.

   - Центрування: Скиньте відображення за допомогою клавіші "C" або кнопки "Центрувати" (скоро).

   - Зсув осі: Перетягуйте графік правою кнопкою миші для огляду кривої.

   - Оцінювач по x: Активуйте лівою кнопкою миші для відображення координат точки на кривій.

# Наші структури:

Для розробки нашого графіка ми використовували кілька структур, особливо для кодування функцій у вигляді дерева та для повернення різних можливих помилок. Ця частина була надана на початку проекту, ми внесли деякі зміни, які представимо.
Файл, який нам надали, містив 6 різних структур:

- дерево: приймає як параметр токен (Typejeton), наступне та попереднє дерево.
- typejeton: приймає як параметр тип значення токена (typelexem) та значення токена (typevaleur).
- typevaleur: приймає як параметр, чи є значення токена дійсним числом, функцією, оператором, і ми вирішили додати можливість включати змінну (char), яка прийме значення x або y для побудови графіка функції від двох змінних.
- typefonction: приймає як параметр математичну функцію (exp, sin, cos,…)
- typeoperateur: приймає як параметр оператор (плюс, мінус, помножити, поділити, піднести до степеня)
- typelexem: приймає як параметр ім'я типу значення токена.

Ми також додали структуру code_erreur, яка пов'язує ім'я помилки з її кодом, наприклад: RACINE_NEGATIVE=301, неможливо обчислити корінь з від'ємного числа, тому якщо користувач запитає це, код поверне цю помилку.

# Пояснення функції Analyse_Lexicale

Функція 'Analyse_Lexicale' перетворює математичний вираз у вигляді рядка в масив токенів. Вона дозволяє розбивати вираз на елементи, які можна легко маніпулювати для подальшого синтаксичного аналізу.

Цей процес токенізації є фундаментальним попереднім етапом для подальшого аналізу та оцінки математичного виразу.

## Загальна робота

Функція приймає чотири параметри:
* 'TabToken': масив, який буде містити згенеровані токени
* 'Expression': рядок, що представляє математичний вираз
* 'erreur': вказівник на змінну, яка буде містити код помилки у разі проблеми
* 'Dimension': вказує, чи є вираз одновимірним або двовимірним (0 для одного виміру, 1 для двох вимірів)

**Важливо**: Лексичний аналізатор вважає великі літери малими.

**Важливо**: Для десяткових чисел використовуйте крапки замість кома.

## Використані підфункції

Функція 'Analyse_Lexicale' слідує послідовності обробки в три основні етапи, кожен з яких використовує свою підфункцію:

1. 'ExpressionSansLesEspaces'
   Ця функція видаляє всі пробіли з математичного виразу.

2. 'MultiplicationImplicite'
   Ця функція виявляє та додає неявні оператори множення. Наприклад, перетворює '2x' на '2*x'.

3. 'DecompositionToken'
   Ця функція розбиває вираз на окремі токени та зберігає їх у масиві 'TabToken', враховуючи параметр розмірності.

## Детальний процес з прикладами

Розглянемо вираз '"3 + cos(5x)"' як приклад.

### Крок 1: Видалення пробілів
'ExpressionSansLesEspaces' перетворює '"3 + cos(5x)"' на '"3+cos(5x)"'.

### Крок 2: Додавання неявних множень
'MultiplicationImplicite' виявляє неявні множення між числами та змінними. Перетворює '"3+cos(5x)"' на '"3+cos(5*x)"'.

### Крок 3: Створення токенів
'DecompositionToken' розбиває вираз на токени:
* '3' → Токен типу REAL зі значенням 3.0
* '+' → Токен типу OPERATOR зі значенням PLUS
* 'cos' → Токен типу FUNCTION зі значенням COS
* '(' → Токен типу PAR_OUV
* '5' → Токен типу REAL зі значенням 5.0
* '*' → Токен типу OPERATOR зі значенням FOIS
* 'x' → Токен типу VARIABLE зі значенням 'x'
* ')' → Токен типу PAR_FERM
* Додавання токена FIN в кінці

## Як 'DecompositionToken' визначає токени

Функція 'DecompositionToken' аналізує символ за символом і використовує кілька підфункцій для правильного визначення кожного токена:

* 'TokenReelPositif': Створює токен для додатних чисел
* 'TokenReelNegatif': Обробляє від'ємні числа (наприклад, "(-2.5)")
* 'TokenOperateur': Визначає оператори (+, -, *, /, **)
* 'TokenFonction': Визначає функції (sin, cos, abs тощо)
* 'TokenVariable': Визначає змінні (x, y) залежно від параметра 'Dimension'

## Керування змінними залежно від розмірності

Функція 'TokenVariable' використовує параметр 'Dimension', щоб визначити, які змінні дозволені:
* Якщо 'Dimension' = 0: дозволена лише змінна 'x'
* Якщо 'Dimension' = 1: дозволені змінні 'x' та 'y'

## Обробка помилок

Функція сигналізує про кілька можливих типів помилок:
* FONCTION_INCONNUE (101): Функція не розпізнана
* NOMBRE_INVALIDE (102): Неправильний формат числа (наприклад, "1.2.3")
* CARACTERE_INCONNUE (103): Нерозпізнаний символ
* VARIABLE_INCONNUE (104): Змінна не дозволена залежно від розмірності

## Повний приклад

Для виразу '"2x + sin(3.5)"' з 'Dimension' = 0:

1. Видалення пробілів: '"2x+sin(3.5)"'
2. Додавання неявних множень: '"2*x+sin(3.5)"'
3. Створення токенів:
   * REAL (2.0)
   * OPERATOR (FOIS)
   * VARIABLE ('x')
   * OPERATOR (PLUS)
   * FUNCTION (SIN)
   * PAR_OUV
   * REAL (3.5)
   * PAR_FERM
   * FIN

# Синтаксичний аналіз

### createEmptyNode

Призначення: Повертає порожнє дерево

Приймає як параметр:

-Нічого

Функціонування функції:

-Створює порожні fg та fd

### buildExpressionTree

Призначення: Рекурсивно будує дерево з масиву токенів

Приймає як параметр:

-масив токенів
-індекс першої комірки для аналізу
-індекс останньої комірки для аналізу
-помилку, отриману при останньому рекурсивному виклику (за замовчуванням 0).

Функціонування функції:

Якщо при останньому рекурсивному виклику була помилка: повертає порожнє дерево в кінці гілки

Якщо індекс початку > індекса кінця: повертає помилку = MEMBRE_VIDE

Якщо є оператор: дерево ділиться на оператор на fg та fd.

В іншому випадку повертає помилку в наступних випадках

- PROBLEME_PARENTHESES_FONCTIONS: не вистачає дужки після функції або дужка не закрита
- MEMBRE_VIDE: якщо оператор не оточений оброблюваними об'єктами, якщо дужки порожні
- PARENTHESE_FERMEE_1_ER_JETON: якщо дужка закрита, не бувши відкритою
- PROBLEMES_NOMBRE_PARENTHESES: якщо кількість відкритих дужок не дорівнює кількості закритих
- PROBLEME_APRES_REEL_OU_VARIABLE: Вважається неможливим
- ABSENCE_FIN: якщо токен "FIN" відсутній

### findLowestPriorityOperator

Призначення: Повертає оператор, по якому потрібно розділити fg та fd.

Приймає як параметр:

-масив токенів
-індекс першої комірки для аналізу
-індекс останньої комірки для аналізу
-помилку, отриману при останньому рекурсивному виклику (за замовчуванням 0).

Функціонування функції:

Ініціалізує глибину складності дужок
За замовчуванням індекс поділу встановлюється на -1.

indiceOperateurMinimal = -1, якщо в функції немає операторів
prioritéOperateurMinimal представляє оператор, по якому потрібно розділити масив токенів.

Проходить по масиву комірка за коміркою та перевіряє, чи є оператор

Якщо комірка є оператором, поточна глибина дужок дорівнює нулю, і оператор поточної комірки більш підходящий для поділу:
indiceOperateurMinimal = поточний індекс
prioriteOperateurMinimal = поточна комірка

Якщо комірка є PAR_OUV:
глибина, пов'язана з дужками, збільшується

Якщо комірка є PAR_FERM:
глибина, пов'язана з дужками, зменшується

Якщо глибина дужок не дорівнює нулю (=> кількість PAR_OUV != кількість PAR_FERM)
помилка = PROBLEMES_NOMBRE_PARENTHESES

### findExpressionLength

Призначення: Повертає довжину масиву

Приймає як параметр:

-Масив токенів

Функціонування функції:

Проходить по масиву, і якщо комірка є кінцевою, функція зупиняється
Якщо FIN не знайдено, тоді кінець = -1

### checkParenthesesBalance

Призначення: Повертає булеве значення щодо балансу кількості дужок.

Приймає як параметр:

-індекс початку масиву для аналізу
-індекс кінця масиву для аналізу
-масив токенів

Функціонування функції:

Проходить по масиву та підраховує кількість PAR_OUV та PAR_FERM

### buildSyntaxTree

Призначення: Будує повне синтаксичне дерево з послідовності токенів

Приймає як параметр:

-масив токенів
-останню помилку, повернуту buildExpressionTree (0 для першого виклику)

Функціонування функції:

Перевіряє, чи існує токен FIN
Якщо існує, дерево будується за допомогою виклику buildExpressionTree
В іншому випадку помилка = ABSENCE_FIN

# ЧАСТИНА ОЦІНЮВАЧА:

Мета оцінювача — обчислити функцію (яка у вигляді дерева) на основі заданих змінних x та y. Його роль важлива для побудови кривих, оскільки дозволяє отримати точки для відображення на графіку. Наш код поділяється на дві основні функції: оцінювач, наша основна функція, яка інтерпретує дерево, та calculer_fonction, допоміжна функція, яка застосовує стандартні математичні функції.
Функція оцінювача:

Її мета — декодувати вхідне дерево. Приймає на вхід:
- Функцію у вигляді дерева
- Значення x та y
- Вказівник code_erreur.
Повертає результат вхідної функції, обчислений на основі змінних x та y.
Ця функція рекурсивна і має чотири випадки зупинки. Перший — якщо вказівник code_erreur змінить значення, це означає, що в функції, яку потрібно обчислити, є помилка, і отже, необхідно зупинити декодування дерева при виникненні помилки. Другий випадок зупинки — якщо основний токен дерева не має типу. Нарешті, функція зупиниться, якщо основний токен дерева є дійсним числом або змінною, що означає, що ми дійшли до листа дерева.
Після цього перевіряється за допомогою функції switch тип основного токена вхідного дерева, якщо це:

- Змінна: повертає значення змінної, отримане на вході функції.
- Дійсне число: повертає значення дійсного числа.
- Оператор: використовує метод "розділити та володарювати" для обчислення операції.
- Функція: використовує другу функцію нашої програми.
Функція calculer_fonction:

Ця функція приймає на вхід тип математичної функції f, змінну x, до якої потрібно застосувати f, та вказівник code_erreur. Повертає застосування f(x). Типи можливих функцій — це універсальні математичні функції, такі як sin, cos або ln.
Спочатку за допомогою функції switch визначається, яка функція використовується, потім перевіряється відсутність помилок перед обчисленням f(x).
У разі помилки:
У разі помилки (наприклад, ділення на нуль, логарифм від'ємного числа тощо) функція повертає некоректне значення та змінює вказівник code_erreur для сигналізації про проблему. Це дозволяє, наприклад, зупинити оцінку або вивести відповідне повідомлення користувачеві.

# Графічне відображення

## 1. Початок

Початковий екран полегшує взаємодію з користувачем. Він надає доступ до різних функцій, таких як перегляд посібника користувача, відображення подяк або запуск режиму відображення. Наразі програма пропонує 2D-відображення, але 3D-версія для функцій з двома змінними знаходиться в розробці нашими інженерами.

## 2. Функції повернення

Функція повернення дозволяє користувачеві повертатися до попередніх меню без перезапуску програми. Можна повернутися на початковий екран, натиснувши на іконку будинку в текстових меню або натиснувши клавішу "Backspace" або "Повернутися" на клавіатурі.

## 3. Верхня панель

Користувач може відображати до 20 виразів. За замовчуванням для кожного випадку представлена базова функція. Потім користувач може натиснути на вираз, щоб змінити його. Крім того, при введенні тексту в одну з трьох текстових областей верхньої панелі можна взаємодіяти з наступними функціями:

### 3.1 Зміна кольору

Програма дозволяє налаштувати колір функцій через меню вибору кольору. Це меню активовується при натисканні на іконку кольорового колеса. Після відкриття воно дозволяє змінювати колір функцій в реальному часі (навіть при утриманні лівої кнопки миші).

### 3.2 Приховати функцію

Ця функція дозволяє користувачеві приховувати або відображати функції за своїм вибором в реальному часі залежно від потреб.

### 3.3 Видалити функцію

Користувач може видаляти вирази, натискаючи лівою кнопкою миші на іконку сміттєвого бака.

### 3.4 Змінити межі

Текстове вікно дозволяє користувачеві змінювати межі виразу в реальному часі для більшої гнучкості.

## 4. Обробка виразу

Після введення виразу він піддається лексичному, а потім синтаксичному аналізу для підготовки до подальшої обробки.

## 5. Відображення функцій

Дерево, створене під час аналізу, використовується для зіставлення кожному значенню інтервалу його зображення на екрані за допомогою функції оцінки. Цей процес повторюється в реальному часі, забезпечуючи динамічне оновлення відображення.

### 5.1 Масштабування

Для кращого графічного аналізу програма дозволяє збільшувати та зменшувати масштаб за допомогою колеса миші. Це змінює відображуваний інтервал функції.

### 5.2 Центрування

Функція центрування дозволяє швидко скинути відображення. Для цього достатньо натиснути клавішу "C" на клавіатурі. Незабаром на правій панелі вікна буде додано кнопку "Центрувати".

### 5.3 Зсув осі

Натискання правою кнопкою миші активує режим "перетягування", який дозволяє користувачеві інтуїтивно переміщуватися графіком.

### 5.4 Оцінювач по x

Оцінювач, активований лівою кнопкою миші, дозволяє користувачеві бачити дві лінії, які перетинають першу криву з списку виразів. Ці лінії слідують за положенням миші по осі абсцис. Відображення показує значення 'x' та значення функції в точці клацання.
