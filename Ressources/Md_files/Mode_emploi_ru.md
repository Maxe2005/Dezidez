# Как использовать:

- Используемые функции: sin(), cos(), tan(), sqrt(), exp(), log(), abs(), sinc(), целое(),
- Для отрицательных значений всегда использовать скобки, например: sin(-2) => sin((-2)) или -4 => (-4)
- Для возведения в степень использовать '**', например: x в степени y => x**y
- Для десятичных чисел использовать '.' вместо ','
- все заглавные буквы считаются строчными

## 1. Начало:

Начальный экран облегчает доступ к функциям, таким как руководство пользователя, благодарности или запуск режима отображения, с 3D-версией в разработке.

## 2. Возврат:

Чтобы вернуться к предыдущим меню без перезапуска программы, нажмите на иконку дома или используйте клавишу "Backspace" или "Возврат".

## 3. Верхняя панель:

Позволяет отображать и изменять до 20 выражений с интерактивными функциями.

   - Изменение цвета: Выберите новый цвет в реальном времени через иконку колеса.

   - Скрыть функцию: Скрывайте или отображайте функцию по мере необходимости в реальном времени.

   - Удалить функцию: Нажмите на иконку корзины, чтобы удалить выражение.

   - Изменить границы: Настройте границы выражения через текстовое окно для большей гибкости.

## 4. Отображение функций:

Оценка функций динамически обновляет их графическое представление.

   - Масштабирование: Используйте колесико мыши для настройки отображения графика.

   - Центрирование: Сбросьте отображение с помощью клавиши "C" или кнопки "Центрировать" (скоро).

   - Смещение осей: Перетаскивайте график с помощью правой кнопки мыши для просмотра кривой.

   - Оценщик по x: Активируйте левой кнопкой мыши для отображения координат точки на кривой.

# Наши структуры:

Для разработки нашего графика мы использовали несколько структур, особенно для кодирования функций в виде дерева и для возврата различных возможных ошибок. Эта часть была предоставлена в начале проекта, мы внесли некоторые изменения, которые представляем.
Файл, который нам предоставили, содержал 6 различных структур:

- дерево: принимает в качестве параметра токен (Typejeton), следующее и предыдущее дерево.
- typejeton: принимает в качестве параметра тип значения токена (typelexem) и значение токена (typevaleur).
- typevaleur: принимает в качестве параметра, является ли значение токена вещественным числом, функцией, оператором, и мы решили добавить возможность включать переменную (char), которая примет значение x или y для построения графика функции от двух переменных.
- typefonction: принимает в качестве параметра математическую функцию (exp, sin, cos,…)
- typeoperateur: принимает в качестве параметра оператор (плюс, минус, умножить, разделить, возвести в степень)
- typelexem: принимает в качестве параметра имя типа значения токена.

Мы также добавили структуру code_erreur, которая связывает имя ошибки с её кодом, например: RACINE_NEGATIVE=301, невозможно вычислить корень из отрицательного числа, поэтому если пользователь запросит это, код вернёт эту ошибку.

# Объяснение функции Analyse_Lexicale

Функция 'Analyse_Lexicale' преобразует математическое выражение в виде строки в массив токенов. Она позволяет разбивать выражение на элементы, которые можно легко манипулировать для последующего синтаксического анализа.

Этот процесс токенизации является фундаментальным предварительным этапом для последующего анализа и оценки математического выражения.

## Общее функционирование

Функция принимает четыре параметра:
* 'TabToken': массив, который будет содержать сгенерированные токены
* 'Expression': строка, представляющая математическое выражение
* 'erreur': указатель на переменную, которая будет содержать код ошибки в случае проблемы
* 'Dimension': указывает, является ли выражение одномерным или двумерным (0 для одной размерности, 1 для двух размерностей)

**Важно**: Лексический анализатор считает заглавные буквы строчными.

**Важно**: Для десятичных чисел использовать точки вместо запятых.

## Используемые подфункции

Функция 'Analyse_Lexicale' следует последовательности обработки в три основных этапа, каждый из которых использует свою подфункцию:

1. 'ExpressionSansLesEspaces'
   Эта функция удаляет все пробелы из математического выражения.

2. 'MultiplicationImplicite'
   Эта функция обнаруживает и добавляет неявные операторы умножения. Например, преобразует '2x' в '2*x'.

3. 'DecompositionToken'
   Эта функция разбивает выражение на отдельные токены и сохраняет их в массиве 'TabToken', учитывая параметр размерности.

## Подробный процесс с примерами

Рассмотрим выражение '"3 + cos(5x)"' в качестве примера.

### Шаг 1: Удаление пробелов
'ExpressionSansLesEspaces' преобразует '"3 + cos(5x)"' в '"3+cos(5x)"'.

### Шаг 2: Добавление неявных умножений
'MultiplicationImplicite' обнаруживает неявные умножения между числами и переменными. Преобразует '"3+cos(5x)"' в '"3+cos(5*x)"'.

### Шаг 3: Создание токенов
'DecompositionToken' разбивает выражение на токены:
* '3' → Токен типа REAL со значением 3.0
* '+' → Токен типа OPERATOR со значением PLUS
* 'cos' → Токен типа FUNCTION со значением COS
* '(' → Токен типа PAR_OUV
* '5' → Токен типа REAL со значением 5.0
* '*' → Токен типа OPERATOR со значением FOIS
* 'x' → Токен типа VARIABLE со значением 'x'
* ')' → Токен типа PAR_FERM
* Добавление токена FIN в конце

## Как 'DecompositionToken' определяет токены

Функция 'DecompositionToken' анализирует символ за символом и использует несколько подфункций для правильного определения каждого токена:

* 'TokenReelPositif': Создаёт токен для положительных чисел
* 'TokenReelNegatif': Обрабатывает отрицательные числа (например, "(-2.5)")
* 'TokenOperateur': Определяет операторы (+, -, *, /, **)
* 'TokenFonction': Определяет функции (sin, cos, abs и т.д.)
* 'TokenVariable': Определяет переменные (x, y) в зависимости от параметра 'Dimension'

## Управление переменными в зависимости от размерности

Функция 'TokenVariable' использует параметр 'Dimension', чтобы определить, какие переменные разрешены:
* Если 'Dimension' = 0: разрешена только переменная 'x'
* Если 'Dimension' = 1: разрешены переменные 'x' и 'y'

## Обработка ошибок

Функция сигнализирует о нескольких возможных типах ошибок:
* FONCTION_INCONNUE (101): Функция не распознана
* NOMBRE_INVALIDE (102): Неправильный формат числа (например, "1.2.3")
* CARACTERE_INCONNUE (103): Нераспознанный символ
* VARIABLE_INCONNUE (104): Переменная не разрешена в зависимости от размерности

## Полный пример

Для выражения '"2x + sin(3.5)"' с 'Dimension' = 0:

1. Удаление пробелов: '"2x+sin(3.5)"'
2. Добавление неявных умножений: '"2*x+sin(3.5)"'
3. Создание токенов:
   * REAL (2.0)
   * OPERATOR (FOIS)
   * VARIABLE ('x')
   * OPERATOR (PLUS)
   * FUNCTION (SIN)
   * PAR_OUV
   * REAL (3.5)
   * PAR_FERM
   * FIN

# Синтаксический анализ

### createEmptyNode

Назначение: Возвращает пустое дерево

Принимает в качестве параметра:

-Ничего

Функционирование функции:

-Создаёт пустые fg и fd

### buildExpressionTree

Назначение: Рекурсивно строит дерево из массива токенов

Принимает в качестве параметра:

-массив токенов
-индекс первой ячейки для анализа
-индекс последней ячейки для анализа
-ошибку, полученную при последнем рекурсивном вызове (по умолчанию 0).

Функционирование функции:

Если при последнем рекурсивном вызове была ошибка: возвращает пустое дерево в конце ветви

Если индекс начала > индекса конца: возвращает ошибку = MEMBRE_VIDE

Если есть оператор: дерево делится на оператор на fg и fd.

В противном случае возвращает ошибку в следующих случаях

- PROBLEME_PARENTHESES_FONCTIONS: не хватает скобки после функции или скобка не закрыта
- MEMBRE_VIDE: если оператор не окружён обрабатываемыми объектами, если скобки пусты
- PARENTHESE_FERMEE_1_ER_JETON: если скобка закрыта, не будучи открытой
- PROBLEMES_NOMBRE_PARENTHESES: если количество открывающих скобок не равно количеству закрывающих
- PROBLEME_APRES_REEL_OU_VARIABLE: Считается невозможным
- ABSENCE_FIN: если токен "FIN" отсутствует

### findLowestPriorityOperator

Назначение: Возвращает оператор, по которому нужно делить fg и fd.

Принимает в качестве параметра:

-массив токенов
-индекс первой ячейки для анализа
-индекс последней ячейки для анализа
-ошибку, полученную при последнем рекурсивном вызове (по умолчанию 0).

Функционирование функции:

Инициализирует глубину сложности скобок
По умолчанию индекс деления устанавливается на -1.

indiceOperateurMinimal = -1, если в функции нет операторов
prioritéOperateurMinimal представляет оператор, по которому нужно разделить массив токенов.

Проходит по массиву ячейка за ячейкой и проверяет, есть ли оператор

Если ячейка является оператором, текущая глубина скобок равна нулю, и оператор текущей ячейки более подходящий для деления:
indiceOperateurMinimal = текущий индекс
prioriteOperateurMinimal = текущая ячейка

Если ячейка является PAR_OUV:
глубина, связанная со скобками, увеличивается

Если ячейка является PAR_FERM:
глубина, связанная со скобками, уменьшается

Если глубина скобок не равна нулю (=> количество PAR_OUV != количество PAR_FERM)
ошибка = PROBLEMES_NOMBRE_PARENTHESES

### findExpressionLength

Назначение: Возвращает длину массива

Принимает в качестве параметра:

-Массив токенов

Функционирование функции:

Проходит по массиву, и если ячейка является конечной, функция останавливается
Если FIN не найден, тогда конец = -1

### checkParenthesesBalance

Назначение: Возвращает булево значение относительно баланса количества скобок.

Принимает в качестве параметра:

-индекс начала массива для анализа
-индекс конца массива для анализа
-массив токенов

Функционирование функции:

Проходит по массиву и считает количество PAR_OUV и PAR_FERM

### buildSyntaxTree

Назначение: Строит полное синтаксическое дерево из последовательности токенов

Принимает в качестве параметра:

-массив токенов
-последнюю ошибку, возвращённую buildExpressionTree (0 для первого вызова)

Функционирование функции:

Проверяет, существует ли токен FIN
Если существует, дерево строится с помощью вызова buildExpressionTree
В противном случае ошибка = ABSENCE_FIN

# ЧАСТЬ ОЦЕНЩИКА:

Цель оценщика — вычислить функцию (которая в виде дерева) на основе заданных переменных x и y. Его роль важна для построения кривых, так как позволяет получить точки для отображения на графике. Наш код делится на две основные функции: оценщик, наша основная функция, которая интерпретирует дерево, и calculer_fonction, вспомогательная функция, которая применяет стандартные математические функции.
Функция оценщика:

Её цель — декодировать входное дерево. Принимает на вход:
- Функцию в виде дерева
- Значения x и y
- Указатель code_erreur.
Возвращает результат входной функции, вычисленный на основе переменных x и y.
Эта функция рекурсивна и имеет четыре случая остановки. Первый — если указатель code_erreur изменит значение, это означает, что в функции, которую нужно вычислить, есть ошибка, и следовательно, необходимо остановить декодирование дерева при возникновении ошибки. Второй случай остановки — если основной токен дерева не имеет типа. Наконец, функция остановится, если основной токен дерева является вещественным числом или переменной, что означает, что мы достигли листа дерева.
После этого проверяется с помощью функции switch тип основного токена входного дерева, если это:

- Переменная: возвращает значение переменной, полученное на входе функции.
- Вещественное число: возвращает значение вещественного числа.
- Оператор: использует метод "разделяй и властвуй" для вычисления операции.
- Функция: использует вторую функцию нашей программы.
Функция calculer_fonction:

Эта функция принимает на вход тип математической функции f, переменную x, к которой нужно применить f, и указатель code_erreur. Возвращает применение f(x). Типы возможных функций — это универсальные математические функции, такие как sin, cos или ln.
Сначала с помощью функции switch определяется, какая функция используется, затем проверяется отсутствие ошибок перед вычислением f(x).
В случае ошибки:
В случае ошибки (например, деление на ноль, логарифм отрицательного числа и т.д.) функция возвращает некорректное значение и изменяет указатель code_erreur для сигнализации о проблеме. Это позволяет, например, остановить оценку или вывести соответствующее сообщение пользователю.

# Графическое отображение

## 1. Начало

Начальный экран облегчает взаимодействие с пользователем. Он предоставляет доступ к различным функциям, таким как просмотр руководства пользователя, отображение благодарностей или запуск режима отображения. В настоящее время программа предлагает 2D-отображение, но 3D-версия для функций с двумя переменными находится в разработке нашими инженерами.

## 2. Функции возврата

Функция возврата позволяет пользователю возвращаться к предыдущим меню без перезапуска программы. Можно вернуться на начальный экран, нажав на иконку в виде дома в текстовых меню или нажав клавишу "Backspace" или "Возврат" на клавиатуре.

## 3. Верхняя панель

Пользователь может отображать до 20 выражений. По умолчанию для каждого случая представлена базовая функция. Затем пользователь может нажать на выражение, чтобы изменить его. Кроме того, при вводе текста в одну из трёх текстовых областей верхней панели можно взаимодействовать со следующими функциями:

### 3.1 Изменение цвета

Программа позволяет настроить цвет функций через меню выбора цвета. Это меню активируется при нажатии на иконку цветового круга. После открытия оно позволяет изменять цвет функций в реальном времени (даже при удержании левой кнопки мыши).

### 3.2 Скрыть функцию

Эта функция позволяет пользователю скрывать или отображать функции по своему выбору в реальном времени в зависимости от потребностей.

### 3.3 Удалить функцию

Пользователь может удалять выражения, нажимая левой кнопкой мыши на иконку корзины.

### 3.4 Изменить границы

Текстовое окно позволяет пользователю изменять границы выражения в реальном времени для большей гибкости.

## 4. Обработка выражения

После ввода выражения оно подвергается лексическому, а затем синтаксическому анализу для подготовки к последующей обработке.

## 5. Отображение функций

Дерево, созданное во время анализа, используется для сопоставления каждому значению интервала его изображение на экране с помощью функции оценки. Этот процесс повторяется в реальном времени, обеспечивая динамическое обновление отображения.

### 5.1 Масштабирование

Для лучшего графического анализа программа позволяет увеличивать и уменьшать масштаб с помощью колесика мыши. Это изменяет отображаемый интервал функции.

### 5.2 Центрирование

Функция центрирования позволяет быстро сбросить отображение. Для этого достаточно нажать клавишу "C" на клавиатуре. Вскоре на правой панели окна будет добавлена кнопка "Центрировать".

### 5.3 Смещение осей

Нажатие правой кнопки мыши активирует режим "перетаскивания", который позволяет пользователю интуитивно перемещаться по графику.

### 5.4 Оценщик по x

Оценщик, активируемый левой кнопкой мыши, позволяет пользователю видеть две линии, пересекающие первую кривую из списка выражений. Эти линии следуют за положением мыши по оси абсцисс. Отображение показывает значение 'x' и значение функции в точке щелчка.
